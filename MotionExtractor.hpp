#pragma once

#include <ctime>
#include <memory>
#include <vector>

#include "PixelOffset.hpp"

class VideoFrame;

namespace Json {
class Value;
}

/**
 * \brief Detects motion by calculating a "static" image and comparing it to the current one.
 *
 * This detection method works by comparing the current frame to a base frame,
 * which is slowsly lerped towards the main frame.
 */
class MotionExtractor final {
public:
	/*
	 * \brief Constructor
	 * \param frameWidth The width of video frames
	 * \param frameHeight The height of video frames
	 * \param videoFPS The frame rate of the video, in frames per second
	 * \param benchmark true to print the number of frames processed each second.
	 */
	MotionExtractor(size_t frameWidth,
	                size_t frameHeight,
	                double videoFPS,
	                bool  benchmark);

	~MotionExtractor();

	/**
	 * \brief Updates the motion mask given a new frame.
	 * \param frame The next frame of video to process
	 * \returns A reference to the motion mask
	 *
	 * The motion mask's red and green channels can be used for user/display purposees.
	 * \see motionMask for details.
	 */
	 VideoFrame& generateMotionMask(const VideoFrame& frame);

	/**
	 * \brief Returns the motion mask last generated by generateMotionMask
	 *
	 * The motion mask's red and green channels can be used for user/display purposees.
	 * \see motionMask for details.
	 */
	VideoFrame& getMotionMask() { return *motionMask; }

	/// Gets the "static" image with moving objects (hopefully) filtered out
	const VideoFrame& getStaticImage() const { return *refImage; }

	/// Derived classes should call this within their reset function
	void reset();

	/// Gets the number of frames processed in the last second
	/// \warning Will return 0 if benchmarking is not enabled
	int getDetectionFPS() { return detectorFPS; }

	/// Sets the amount two pixels must be different for them to be considered moving
	void setSensitivity(int newSens);

	/// Sets the maximum limit for the stable record of each pixel, in seconds
	void setSettleTime(double newTime);

	/// Pixels will be erased if they are not neighbored by this many other moving pixels (set to 0 to erase)
	void setErosion(int newErosion);

	/// \see setSensitvity
	int getSensitivity() const;

	/// \see setSettleTime
	double getSettleTime() const;

	/// \see setErosion
	int getErosion() const;

	void save(Json::Value& paramsObject) const;

	void load(Json::Value& paramsObject);

	// No copy or assign
	MotionExtractor(const MotionExtractor&) = delete;
	MotionExtractor& operator=(const MotionExtractor&) = delete;

private:
	/// Returns true if any of the channels in the two given pixels differ by MotionExtractor::motionThreshold
	bool pixelIsDifferent(unsigned char* __restrict pa,
	                      unsigned char* __restrict pb);

	/// Downscales an image
	void downscale(const VideoFrame& frame, unsigned char* down);

	/**
	 * \brief The mask of "moving" pixels
	 *
	 * This mask is a 24-bit RGB image so that it can be used for both display and programmatic purposes.
	 * The motion mask is contained in the blue channel - the red and green channels can be used as-desired
	 * by the user
	 * \todo Switch to 8 or 16-bit color?
	 */
	std::unique_ptr<VideoFrame> motionMask;

	/// The video's frame rate (used for settle time calculateions)
	double fps;

	/// The amount two pixels must be different for them to be considered moving
	int motionThreshold;

	/// Maximum limit for the stable record of each pixel, in frames
	unsigned int stableCap;

	/// Moving pixels will be erased if they are not neighbored by this many other moving pixels
	int erosionLevel;

	std::unique_ptr<VideoFrame> erodedMask;

	/// Offsets for adjacent pixels in the motion mask (used for erosion)
	std::vector<PixelOffset> offs;

	/// The current image
	std::unique_ptr<VideoFrame> currentImage;

	/// The numer of frames since each pixel of the current image changed
	/// significantly
	unsigned int* currentStableTimes;

	/// The "background" image
	std::unique_ptr<VideoFrame> refImage;

	/// The number of frames each pixel in the background image remained stable
	/// to earn its place in the background
	unsigned int* stableRecords;

	/// True before a single frame is processed.
	/// The first frame is copied to the reference image to avoid the formation of a screen-wide delta for one frame.
	bool firstFrame;

	// Image dimensions and such
	size_t imageWidth; ///< Downscaled image width
	size_t imageHeight; ///< Downscaled image height
	size_t imageArea; ///< Downscaled image area (width * height)
	size_t imageSize; ///< Downscaled image size (area * bytes per pixel)
	size_t srcLineSize; ///< Byte size of a source image row
	size_t destLineSize; ///< Byte size of a downscaled image row

	bool benchmarking; ///< true if tracking how many frames per second the detector can process
	clock_t lastMark; ///< Used for benchmarking
	int detectorFPS; ///< Detection frames per second as measured by the benchmarking
	int framesCounted; ///< Frames processed since last second
};
